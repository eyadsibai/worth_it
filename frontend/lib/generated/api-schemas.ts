/**
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file is automatically generated from the backend OpenAPI spec.
 * To regenerate, run: ./scripts/generate-types.sh
 *
 * Source: backend/src/worth_it/api.py (FastAPI)
 * Generator: openapi-zod-client
 */

import { makeApi, Zodios, type ZodiosOptions } from "@zodios/core";
import { z } from "zod";

const HealthCheckResponse = z.object({ status: z.string(), version: z.string() }).passthrough();
const DilutionRound = z
  .object({
    year: z.number().int(),
    dilution: z.number(),
    new_salary: z.number(),
    is_safe_note: z.boolean(),
    valuation_at_sale: z.number(),
    percent_to_sell: z.number(),
    status: z.string(),
  })
  .partial()
  .passthrough();
const MonthlyDataGridRequest = z
  .object({
    exit_year: z.number().int().gte(1).lte(20),
    current_job_monthly_salary: z.number().gte(0),
    startup_monthly_salary: z.number().gte(0),
    current_job_salary_growth_rate: z.number().gte(0).lte(1),
    dilution_rounds: z.union([z.array(DilutionRound), z.null()]).optional(),
  })
  .passthrough();
const MonthlyDataGridResponse = z
  .object({ data: z.array(z.object({}).partial().passthrough()) })
  .passthrough();
const ValidationError = z
  .object({ loc: z.array(z.union([z.string(), z.number()])), msg: z.string(), type: z.string() })
  .passthrough();
const HTTPValidationError = z
  .object({ detail: z.array(ValidationError) })
  .partial()
  .passthrough();
const OpportunityCostRequest = z
  .object({
    monthly_data: z.array(z.object({}).partial().passthrough()),
    annual_roi: z.number().gte(0).lte(1),
    investment_frequency: z.string().regex(/^(Monthly|Annually)$/),
    options_params: z.union([z.object({}).partial().passthrough(), z.null()]).optional(),
    startup_params: z.union([z.object({}).partial().passthrough(), z.null()]).optional(),
  })
  .passthrough();
const OpportunityCostResponse = z
  .object({ data: z.array(z.object({}).partial().passthrough()) })
  .passthrough();
const StartupScenarioRequest = z
  .object({
    opportunity_cost_data: z.array(z.object({}).partial().passthrough()),
    startup_params: z.object({}).partial().passthrough(),
  })
  .passthrough();
const StartupScenarioResponse = z
  .object({
    results_df: z.array(z.object({}).partial().passthrough()),
    final_payout_value: z.number(),
    final_opportunity_cost: z.number(),
    payout_label: z.string(),
    breakeven_label: z.string(),
    total_dilution: z.union([z.number(), z.null()]).optional(),
    diluted_equity_pct: z.union([z.number(), z.null()]).optional(),
  })
  .passthrough();
const IRRRequest = z
  .object({ monthly_surpluses: z.array(z.number()), final_payout_value: z.number() })
  .passthrough();
const IRRResponse = z.object({ irr: z.union([z.number(), z.null()]) }).passthrough();
const NPVRequest = z
  .object({
    monthly_surpluses: z.array(z.number()),
    annual_roi: z.number().gte(0).lte(1),
    final_payout_value: z.number(),
  })
  .passthrough();
const NPVResponse = z.object({ npv: z.union([z.number(), z.null()]) }).passthrough();
const MonteCarloRequest = z
  .object({
    num_simulations: z.number().int().gte(1).lte(10000),
    base_params: z.object({}).partial().passthrough(),
    sim_param_configs: z.object({}).partial().passthrough(),
  })
  .passthrough();
const MonteCarloResponse = z
  .object({ net_outcomes: z.array(z.number()), simulated_valuations: z.array(z.number()) })
  .passthrough();
const SensitivityAnalysisRequest = z
  .object({
    base_params: z.object({}).partial().passthrough(),
    sim_param_configs: z.object({}).partial().passthrough(),
  })
  .passthrough();
const SensitivityAnalysisResponse = z
  .object({ data: z.union([z.array(z.object({}).partial().passthrough()), z.null()]) })
  .passthrough();
const DilutionFromValuationRequest = z
  .object({ pre_money_valuation: z.number().gte(0), amount_raised: z.number().gte(0) })
  .passthrough();
const DilutionFromValuationResponse = z.object({ dilution: z.number() }).passthrough();
const VestingSchedule = z
  .object({
    total_shares: z.number().int().gte(0),
    vesting_months: z.number().int().gte(1).lte(120),
    cliff_months: z.number().int().gte(0).lte(48),
    start_date: z.union([z.string(), z.null()]).optional(),
    vested_shares: z.number().int().gte(0).optional().default(0),
  })
  .passthrough();
const Stakeholder = z
  .object({
    id: z.string(),
    name: z.string().min(1),
    type: z.enum(["founder", "employee", "investor", "advisor"]),
    shares: z.number().int().gte(0),
    ownership_pct: z.number().gte(0).lte(100),
    share_class: z.enum(["common", "preferred"]),
    vesting: z.union([VestingSchedule, z.null()]).optional(),
  })
  .passthrough();
const CapTable_Input = z
  .object({
    stakeholders: z.array(Stakeholder),
    total_shares: z.number().int().gte(0).default(10000000),
    option_pool_pct: z.number().gte(0).lte(100).default(10),
  })
  .partial()
  .passthrough();
const SAFE = z
  .object({
    id: z.string(),
    type: z.string().optional().default("SAFE"),
    investor_name: z.string().min(1),
    investment_amount: z.number().gt(0),
    valuation_cap: z.union([z.number(), z.null()]).optional(),
    discount_pct: z.union([z.number(), z.null()]).optional(),
    pro_rata_rights: z.boolean().optional().default(false),
    mfn_clause: z.boolean().optional().default(false),
    date: z.union([z.string(), z.null()]).optional(),
    status: z.enum(["outstanding", "converted", "cancelled"]).optional().default("outstanding"),
    converted_shares: z.union([z.number(), z.null()]).optional(),
    conversion_price: z.union([z.number(), z.null()]).optional(),
  })
  .passthrough();
const ConvertibleNote = z
  .object({
    id: z.string(),
    type: z.string().optional().default("CONVERTIBLE_NOTE"),
    investor_name: z.string().min(1),
    principal_amount: z.number().gt(0),
    interest_rate: z.number().gte(0).lte(100),
    interest_type: z.enum(["simple", "compound"]).optional().default("simple"),
    valuation_cap: z.union([z.number(), z.null()]).optional(),
    discount_pct: z.union([z.number(), z.null()]).optional(),
    maturity_months: z.number().int().gte(1).lte(120),
    date: z.union([z.string(), z.null()]).optional(),
    status: z.enum(["outstanding", "converted", "cancelled"]).optional().default("outstanding"),
    accrued_interest: z.union([z.number(), z.null()]).optional(),
    converted_shares: z.union([z.number(), z.null()]).optional(),
    conversion_price: z.union([z.number(), z.null()]).optional(),
  })
  .passthrough();
const PricedRound = z
  .object({
    id: z.string(),
    type: z.string().optional().default("PRICED_ROUND"),
    round_name: z.string().min(1),
    lead_investor: z.union([z.string(), z.null()]).optional(),
    pre_money_valuation: z.number().gt(0),
    amount_raised: z.number().gt(0),
    price_per_share: z.number().gt(0),
    date: z.union([z.string(), z.null()]).optional(),
    liquidation_multiplier: z.number().gte(1).optional().default(1),
    participating: z.boolean().optional().default(false),
    participation_cap: z.union([z.number(), z.null()]).optional(),
    new_shares_issued: z.number().int().gte(0),
    post_money_valuation: z.union([z.number(), z.null()]).optional(),
  })
  .passthrough();
const CapTableConversionRequest = z
  .object({
    cap_table: CapTable_Input.describe("Cap table with all stakeholders."),
    instruments: z.array(z.union([SAFE, ConvertibleNote])),
    priced_round: PricedRound.describe("A priced equity financing round."),
  })
  .passthrough();
const CapTable_Output = z
  .object({
    stakeholders: z.array(Stakeholder),
    total_shares: z.number().int().gte(0).default(10000000),
    option_pool_pct: z.number().gte(0).lte(100).default(10),
  })
  .partial()
  .passthrough();
const ConvertedInstrumentDetail = z
  .object({
    instrument_id: z.string(),
    instrument_type: z.enum(["SAFE", "CONVERTIBLE_NOTE"]),
    investor_name: z.string(),
    investment_amount: z.number(),
    conversion_price: z.number(),
    price_source: z.enum(["cap", "discount"]),
    shares_issued: z.number().int(),
    ownership_pct: z.number(),
    accrued_interest: z.union([z.number(), z.null()]).optional(),
  })
  .passthrough();
const ConversionSummary = z
  .object({
    instruments_converted: z.number().int(),
    total_shares_issued: z.number().int(),
    total_dilution_pct: z.number(),
  })
  .passthrough();
const CapTableConversionResponse = z
  .object({
    updated_cap_table: CapTable_Output.describe("Cap table with all stakeholders."),
    converted_instruments: z.array(ConvertedInstrumentDetail),
    summary: ConversionSummary.describe("Summary of conversion results."),
  })
  .passthrough();
const PreferenceTier = z
  .object({
    id: z.string(),
    name: z.string().min(1),
    seniority: z.number().int().gte(1),
    investment_amount: z.number().gt(0),
    liquidation_multiplier: z.number().gte(1).optional().default(1),
    participating: z.boolean().optional().default(false),
    participation_cap: z.union([z.number(), z.null()]).optional(),
    stakeholder_ids: z.array(z.string()).optional(),
  })
  .passthrough();
const WaterfallRequest = z
  .object({
    cap_table: CapTable_Input.describe("Cap table with all stakeholders."),
    preference_tiers: z.array(PreferenceTier),
    exit_valuations: z.array(z.number()).min(1),
  })
  .passthrough();
const WaterfallStep = z
  .object({
    step_number: z.number().int().gte(1),
    description: z.string(),
    amount: z.number().gte(0),
    recipients: z.array(z.string()),
    remaining_proceeds: z.number().gte(0),
  })
  .passthrough();
const StakeholderPayout = z
  .object({
    stakeholder_id: z.string(),
    name: z.string(),
    payout_amount: z.number().gte(0),
    payout_pct: z.number().gte(0).lte(100),
    investment_amount: z.union([z.number(), z.null()]).optional(),
    roi: z.union([z.number(), z.null()]).optional(),
  })
  .passthrough();
const WaterfallDistribution = z
  .object({
    exit_valuation: z.number().gt(0),
    waterfall_steps: z.array(WaterfallStep),
    stakeholder_payouts: z.array(StakeholderPayout),
    common_pct: z.number().gte(0).lte(100),
    preferred_pct: z.number().gte(0).lte(100),
  })
  .passthrough();
const WaterfallResponse = z
  .object({
    distributions_by_valuation: z.array(WaterfallDistribution),
    breakeven_points: z.record(z.string(), z.number()),
  })
  .passthrough();
const DilutionStakeholderInput = z
  .object({
    name: z.string().min(1),
    type: z.enum(["founder", "employee", "investor", "advisor"]),
    ownership_pct: z.number().gte(0).lte(100),
  })
  .passthrough();
const DilutionPreviewRequest = z
  .object({
    stakeholders: z.array(DilutionStakeholderInput).optional(),
    option_pool_pct: z.number().gte(0).lte(100).optional().default(0),
    pre_money_valuation: z.number().gt(0),
    amount_raised: z.number().gt(0),
    investor_name: z.string().min(1).optional().default("New Investor"),
  })
  .passthrough();
const DilutionResultItem = z
  .object({
    name: z.string(),
    type: z.enum(["founder", "employee", "investor", "advisor", "option_pool", "new_investor"]),
    before_pct: z.number(),
    after_pct: z.number(),
    dilution_pct: z.number(),
    is_new: z.boolean(),
  })
  .passthrough();
const DilutionPreviewResponse = z
  .object({
    dilution_results: z.array(DilutionResultItem),
    post_money_valuation: z.number(),
    dilution_factor: z.number(),
  })
  .passthrough();
const ScenarioResultsInfo = z
  .object({
    netOutcome: z.number(),
    finalPayoutValue: z.number(),
    finalOpportunityCost: z.number(),
    breakeven: z.union([z.string(), z.null()]).optional(),
  })
  .passthrough();
const ScenarioEquityInfo = z.object({ monthlySalary: z.number() }).passthrough();
const ScenarioInput = z
  .object({
    name: z.string().min(1),
    results: ScenarioResultsInfo.describe("Results information for a scenario."),
    equity: ScenarioEquityInfo.describe("Equity information for a scenario."),
  })
  .passthrough();
const ScenarioComparisonRequest = z
  .object({ scenarios: z.array(ScenarioInput).min(1) })
  .passthrough();
const WinnerResult = z
  .object({
    winner_name: z.string(),
    winner_index: z.number().int(),
    net_outcome_advantage: z.number(),
    is_tie: z.boolean(),
  })
  .passthrough();
const MetricDiff = z
  .object({
    metric: z.string(),
    label: z.string(),
    values: z.array(z.number()),
    scenario_names: z.array(z.string()),
    absolute_diff: z.number(),
    percentage_diff: z.number(),
    better_scenario: z.string(),
    higher_is_better: z.boolean(),
  })
  .passthrough();
const ComparisonInsight = z
  .object({
    type: z.enum(["winner", "tradeoff", "observation"]),
    title: z.string(),
    description: z.string(),
    scenario_name: z.union([z.string(), z.null()]).optional(),
    icon: z.union([z.enum(["trophy", "scale", "info"]), z.null()]).optional(),
  })
  .passthrough();
const ScenarioComparisonResponse = z
  .object({
    winner: WinnerResult.describe("Result of identifying the winning scenario."),
    metric_diffs: z.array(MetricDiff),
    insights: z.array(ComparisonInsight),
  })
  .passthrough();
const RevenueMultipleRequest = z
  .object({
    annual_revenue: z.number().gte(0).describe("Annual revenue (ARR or TTM)"),
    revenue_multiple: z.number().gt(0).lte(100).describe("Revenue multiple (e.g., 10x)"),
    growth_rate: z
      .union([z.number(), z.null()])
      .describe("YoY revenue growth rate (e.g., 0.5 for 50%)")
      .optional(),
    industry_benchmark_multiple: z
      .union([z.number(), z.null()])
      .describe("Industry average revenue multiple for comparison")
      .optional(),
  })
  .passthrough();
const ValuationResultResponse = z
  .object({
    method: z.enum(["revenue_multiple", "dcf", "vc_method"]),
    valuation: z.number(),
    confidence: z.number(),
    inputs: z.object({}).partial().passthrough(),
    notes: z.string(),
  })
  .passthrough();
const DCFRequest = z
  .object({
    projected_cash_flows: z.array(z.number()).min(1).describe("Projected annual free cash flows"),
    discount_rate: z
      .number()
      .gt(0)
      .lte(1)
      .describe("WACC or required rate of return (e.g., 0.12 for 12%)"),
    terminal_growth_rate: z
      .union([z.number(), z.null()])
      .describe("Perpetual growth rate for terminal value")
      .optional(),
  })
  .passthrough();
const VCMethodRequest = z
  .object({
    projected_exit_value: z.number().gt(0).describe("Expected exit valuation (acquisition/IPO)"),
    exit_year: z.number().int().gte(1).lte(15).describe("Years until exit"),
    target_return_multiple: z
      .union([z.number(), z.null()])
      .describe("Target return multiple (e.g., 10x)")
      .optional(),
    target_irr: z
      .union([z.number(), z.null()])
      .describe("Target IRR (e.g., 0.5 for 50%)")
      .optional(),
    expected_dilution: z
      .number()
      .gte(0)
      .lt(1)
      .describe("Expected dilution from future rounds")
      .optional()
      .default(0),
    investment_amount: z
      .union([z.number(), z.null()])
      .describe("Investment amount for pre-money calculation")
      .optional(),
    exit_probability: z
      .number()
      .gt(0)
      .lte(1)
      .describe("Probability of achieving projected exit")
      .optional()
      .default(1),
  })
  .passthrough();
const ValuationCompareRequest = z
  .object({
    revenue_multiple: z.union([RevenueMultipleRequest, z.null()]),
    dcf: z.union([DCFRequest, z.null()]),
    vc_method: z.union([VCMethodRequest, z.null()]),
  })
  .partial()
  .passthrough();
const ValuationCompareResponse = z
  .object({
    results: z.array(ValuationResultResponse),
    min_valuation: z.number(),
    max_valuation: z.number(),
    average_valuation: z.number(),
    weighted_average: z.number(),
    range_pct: z.number(),
    outliers: z.array(z.string()),
    insights: z.array(z.string()),
  })
  .passthrough();

export const schemas = {
  HealthCheckResponse,
  DilutionRound,
  MonthlyDataGridRequest,
  MonthlyDataGridResponse,
  ValidationError,
  HTTPValidationError,
  OpportunityCostRequest,
  OpportunityCostResponse,
  StartupScenarioRequest,
  StartupScenarioResponse,
  IRRRequest,
  IRRResponse,
  NPVRequest,
  NPVResponse,
  MonteCarloRequest,
  MonteCarloResponse,
  SensitivityAnalysisRequest,
  SensitivityAnalysisResponse,
  DilutionFromValuationRequest,
  DilutionFromValuationResponse,
  VestingSchedule,
  Stakeholder,
  CapTable_Input,
  SAFE,
  ConvertibleNote,
  PricedRound,
  CapTableConversionRequest,
  CapTable_Output,
  ConvertedInstrumentDetail,
  ConversionSummary,
  CapTableConversionResponse,
  PreferenceTier,
  WaterfallRequest,
  WaterfallStep,
  StakeholderPayout,
  WaterfallDistribution,
  WaterfallResponse,
  DilutionStakeholderInput,
  DilutionPreviewRequest,
  DilutionResultItem,
  DilutionPreviewResponse,
  ScenarioResultsInfo,
  ScenarioEquityInfo,
  ScenarioInput,
  ScenarioComparisonRequest,
  WinnerResult,
  MetricDiff,
  ComparisonInsight,
  ScenarioComparisonResponse,
  RevenueMultipleRequest,
  ValuationResultResponse,
  DCFRequest,
  VCMethodRequest,
  ValuationCompareRequest,
  ValuationCompareResponse,
};

const endpoints = makeApi([
  {
    method: "post",
    path: "/api/cap-table/convert",
    description: `Convert SAFEs and Convertible Notes to equity when a priced round occurs.

This endpoint takes the current cap table, outstanding instruments, and a
new priced round, then calculates how each SAFE/Note converts to shares.

The conversion follows the &quot;best of both&quot; rule:
- SAFEs/Notes convert at the lower of cap price or discount price
- Notes include accrued interest in the conversion amount
- New stakeholders are created for each converted instrument`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: CapTableConversionRequest,
      },
    ],
    response: CapTableConversionResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/dilution",
    description: `Calculate dilution percentage from fundraising round.

This endpoint computes how much ownership dilution occurs
based on pre-money valuation and amount raised.`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: DilutionFromValuationRequest,
      },
    ],
    response: z.object({ dilution: z.number() }).passthrough(),
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/dilution/preview",
    description: `Calculate dilution impact of a new funding round on existing stakeholders.

This endpoint computes how ownership percentages change when new investment
comes in. It shows before/after ownership for each stakeholder, option pool,
and the new investor.

Key features:
- Calculates dilution factor from pre/post money valuation
- Shows percentage change for each existing stakeholder
- Handles option pool dilution
- Returns new investor ownership percentage`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: DilutionPreviewRequest,
      },
    ],
    response: DilutionPreviewResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/irr",
    description: `Calculate the Internal Rate of Return (IRR).

This endpoint computes the annualized IRR based on monthly cash flows
and the final equity payout.`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: IRRRequest,
      },
    ],
    response: IRRResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/monte-carlo",
    description: `Run Monte Carlo simulation for probabilistic analysis.

This endpoint performs thousands of simulations with varying parameters
to understand the range of potential outcomes.`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: MonteCarloRequest,
      },
    ],
    response: MonteCarloResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/monthly-data-grid",
    description: `Create a DataFrame with monthly financial projections.

This endpoint creates a monthly data grid showing salary differences,
surplus calculations, and cash flows over the analysis period.`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: MonthlyDataGridRequest,
      },
    ],
    response: MonthlyDataGridResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/npv",
    description: `Calculate the Net Present Value (NPV).

This endpoint computes the NPV of the investment decision,
accounting for the time value of money.`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: NPVRequest,
      },
    ],
    response: NPVResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/opportunity-cost",
    description: `Calculate the opportunity cost of foregone salary.

This endpoint calculates the future value of the salary difference
between current job and startup job, accounting for investment returns.`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: OpportunityCostRequest,
      },
    ],
    response: OpportunityCostResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/scenarios/compare",
    description: `Compare multiple scenarios to identify the best option.

This endpoint analyzes multiple scenarios and provides:
- Winner identification (highest net outcome)
- Metric differences (absolute and percentage)
- Human-readable insights about trade-offs

Key features:
- Identifies winning scenario by net outcome
- Detects ties when scenarios have equal outcomes
- Compares key metrics (net outcome, payout, opportunity cost)
- Generates insights about salary vs equity trade-offs
- Finds earliest breakeven scenario`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: ScenarioComparisonRequest,
      },
    ],
    response: ScenarioComparisonResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/sensitivity-analysis",
    description: `Run sensitivity analysis to identify key variables.

This endpoint analyzes how each variable impacts the final outcome
to identify the most influential factors.`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: SensitivityAnalysisRequest,
      },
    ],
    response: SensitivityAnalysisResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/startup-scenario",
    description: `Calculate financial outcomes for a startup equity package.

This endpoint evaluates both RSU and Stock Option scenarios,
including dilution effects and breakeven analysis.`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: StartupScenarioRequest,
      },
    ],
    response: StartupScenarioResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/valuation/compare",
    description: `Calculate and compare valuations from multiple methods.

This endpoint runs all provided valuation methods and synthesizes
the results into a comparison with insights and recommendations.

Returns:
- Individual results from each method
- Min/max/average/weighted average valuations
- Outlier identification
- Actionable insights about the valuation range`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: ValuationCompareRequest,
      },
    ],
    response: ValuationCompareResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/valuation/dcf",
    description: `Calculate company valuation using Discounted Cash Flow method.

This method values a company based on the present value of projected
future cash flows, plus a terminal value for perpetual growth.

Formula: PV &#x3D; Σ(CFt / (1+r)^t) + Terminal Value`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: DCFRequest,
      },
    ],
    response: ValuationResultResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/valuation/revenue-multiple",
    description: `Calculate company valuation using Revenue Multiple method.

This method values a company based on a multiple of its annual revenue,
adjusted for growth rate. Common for SaaS and tech companies.

Formula: Valuation &#x3D; Annual Revenue × Revenue Multiple × Growth Adjustment`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: RevenueMultipleRequest,
      },
    ],
    response: ValuationResultResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/valuation/vc-method",
    description: `Calculate company valuation using VC Method.

This method works backwards from a projected exit value to determine
what valuation makes sense today given target investor returns.

Formula: Post-Money &#x3D; Exit Value × Exit Probability × (1 - Dilution) / Target Multiple`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: VCMethodRequest,
      },
    ],
    response: ValuationResultResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "post",
    path: "/api/waterfall",
    description: `Calculate exit proceeds distribution using waterfall analysis.

This endpoint performs a liquidation waterfall analysis showing how exit
proceeds are distributed among stakeholders respecting liquidation preferences.

Key features:
- Seniority-based preference ordering (senior tiers paid first)
- Participating vs non-participating preferred handling
- Participation cap enforcement
- Automatic conversion decision for non-participating preferred
- Pari passu (equal seniority) proportional distribution`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: WaterfallRequest,
      },
    ],
    response: WaterfallResponse,
    errors: [
      {
        status: 422,
        description: `Validation Error`,
        schema: HTTPValidationError,
      },
    ],
  },
  {
    method: "get",
    path: "/health",
    description: `Health check endpoint to verify API is running.`,
    requestFormat: "json",
    response: HealthCheckResponse,
  },
]);

export const generatedApi = new Zodios(endpoints);

export function createApiClient(baseUrl: string, options?: ZodiosOptions) {
  return new Zodios(baseUrl, endpoints, options);
}
